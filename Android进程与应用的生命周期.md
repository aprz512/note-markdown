# Android进程与应用的生命周期

官方文档在[这里](https://developer.android.com/guide/components/activities/process-lifecycle)。

本来，官方文档的部分内容已经汉化了，但是翻译实在是惨不忍睹，而且有些内容**与原文还不一致**，真不晓得是怎么回事。

大多数情况下，每个 Android 应用程序运行在自己的 Liunx 进程当中。在应用中的某些代码需要运行的时候，这个进程就会被创建出来，它会一直运行，直到该进程不再被需要了或者系统需要释放该进程占用的内存以便让别的应用运行。

Android 有一个特殊的基本特征：**应用程序进程的生命周期不是由自己本身直接控制的**。取而代之的，是由系统通过几个方面的综合考量来决定的：系统知道的正在运行的应用程序，这些应用程序对用户的重要性，系统可用的剩余内存。

开发者需要理解应用程序的不同组件（特别是 Activity，Service，BroadcastReceiver）对应用程序进程生命周期的影响。如果没有正确的使用这些组件，可能会导致你在执行某些很重要的任务时突然进程被系统给干掉了。

这里有一个例子，是关于进程生命周期的 bug 的。我们在使用 BroadcastReceiver 的时候，当它的 onReceive 方法被触发，我们会开启一个线程去执行任务，onReceive 方法会直接返回。一旦 onReceive 方法返回了，系统就会认为 BroadcastReceiver 不再处于活动状态，所以，它所在的进程也就不需要了（除非进程里面还有其他的组件处于活动状态）。然后系统可能在任何时候杀掉这个进程来回收内存，这样就会终止进程里面正在运行的线程。这个问题的解决方案是使用 JobService，使用了 JobSerive 之后，系统就会知道进程里面仍然有活要干。

为了确定在内存不足的时候应该干掉哪些进程，Android 会根据进程中运行的组件以及这个组件的状态来给每个进程分配一个级别（按重要性排序）：

1. **前台进程**：用户正在与之交互的进程。前台进程有多种产生的情况：

   - 有一个用户正在交互的处于屏幕最顶部的 Activity（onResume 执行过了）
   - 有一个正在运行的广播（BroadcastReceiver.onReceive() 方法正在执行）
   - 有一个正在执行回调方法代码（onCreate，onStart，onDestroy）的 Service

   系统中这样的进程非常少，只有当可用内存极少，而且这些进程都无法正常运行的时候，才会将它们杀掉。

   文档还有一句话，我不是很理解：

   >  Generally, at this point, the device has reached a memory paging state, so this action is required in order to keep the user interface responsive.

   **内存分页我知道，内存分页状态是个啥？？？**

2. **可见进程**：可见进程中运行的任务用户是可以注意到的，所以杀掉它会给用户体验产生明显的负面影响。满足下面的一些条件的是可见进程：

   - Activity 可见但是不处于前台，比如：一个前台的 activity 以 dialog 的形式显示出来，那么在它后面的那个 activity 就是可见状态。

   - Service 调用了  `Service.startForeground()` 方法。这会让系统意识到该服务是会让用户注意到或者可见的。

   - > It is hosting a service that the system is using for a particular feature that the user is aware, such as a live wallpaper, input method service, etc.
     >
     > 这个我不太明白意思。

   可见进程的数量比前台进程要多，但是也多不了多少，处于可管控的范围之内。这些进程是非常重要的，只有在前台进程无法正常运行的时候，才会杀掉它们。

3. **服务进程**：一个Service通过 `startService()` 方法启动即为服务进程。尽管它们对用户不可见，但是它们通常都在后台做一些用户关系的事情（比如：上传与下载）。所以系统一般也不会杀掉它们，除非系统无法保证所有的前台与可见进程正常运行。

   长时间运行的服务（超过30分钟）其优先级会降低（在下面所说的 LRU 表中会向后移动）。这有助于避免出现内存泄漏或其他问题的长时间运行的服务占用大量RAM而导致系统无法有效使用缓存进程的情形。

4. **缓存进程**：缓存进程是指当前不需要的，当系统需要内存的时候是可以随意杀掉的进程。在一个正常运行的系统中，内存管理应该只会涉及到缓存进程：运行良好的系统将始终提供多个缓存进程（以便在应用程序之间进行更高效的切换），并根据需要定期终止最旧的进程。只有在非常极端（且不可取）的情况下，系统才会杀死所有缓存进程，而且必须开始终止服务进程。

   这些进程通常保留了一个或者多个 Activity 的实例（onStop 方法被调用而且返回了），这些 Activity 对用户都不可见。如果开发者正确的实现了 Activity 的生命周期，当系统杀掉这些进程的时候，用户是感知不到的，而且当用户返回这个 App 的时候，也不会影响用户体验：因为系统保存了当前 Activity 的状态，会重新创建该 Activity。

   这些进程保存在伪LRU列表中，列表中的最后一个进程是第一个被回收内存的进程。这个列表通常会将更有用的进程（桌面应用程序，用户最后一个使用的 app）放到其他进程的前面。杀掉进程可能还会有其他的策略（依赖于具体平台的实现）：对进程的数量进行限制，对进程可缓存的时间进行限制。

   在决定如何对进程进行分类时，系统将根据进程中当前活动的所有组件中找到的最重要级别做出决策。具体查看  `Activity`, `Service`, and `BroadcastReceiver` 的文档。它们的文档都详细地描述了它们是如何影响应用程序的整个生命周期的。

   当一个进程被其他进程依赖时，该进程的优先级可能会增加。例如，进程A使用Context.BIND_AUTO_CREATE标志绑定到Service，或者正在使用进程B中的ContentProvider，则进程B的重要级别将始终至少与进程A一样重要。

   
