## ThreadPoolExecutor 源码分析

# 核心线程数和最大线程数

当一个任务通过 execute(Runnable) 方法提交的时候：
1. 如果线程的数量 < 核心线程数，创建一个新的线程来运行该任务。
2. 如果核心线程数 < 线程的数量 < 最大线程数，将该任务放入等待队列中。如果等待队列以满，创建新的线程来运行该任务。
3. 如果等待队列已满，并且无法线程的数量已将达到了最大值，用拒绝策略来执行该任务。

# 等待队列

1. 直接传递 （SynchronousQueue）
	当试图将任务放入队列中时，都会新建一个线程来处理该任务，该队列不会储存任何一个任务。
    通常，使用该队列时，需要设置最大线程数为无边界值，这样可以保证任务不会被拒绝。

2. 无边界队列 （LinkedBlockingQueue）
	使用这个队列，由于队列的容量是无边界的，所以当线程的数量达到核心线程的数量时，就不会再新创建线程了，
    即 maximumPoolSize 这个值就没有什么意义了。

3. 有界队列 （ArrayBlockingQueue） -- 这段还是去看源码注释吧，大概是这个意思。
	使用这个队列，可以预防资源耗尽（最大线程数较小的时候），但是很难在性能和资源消耗中达到一个平衡。
    用大队列和小线程池，可以减少 CPU 使用率，系统资源等，但是会降低吞吐量。
    是小队列和大线程池，会导致 CPU 调度过载，也会降低吞吐量。

# 拒绝策略

1. AbortPolicy 抛出运行时异常

2. CallerRunsPolicy 调用 execute(Runnable) 的线程来执行 Runnable 的 run 方法。

3. DiscardPolicy 直接忽略该任务

4. DiscardOldestPolicy 将等待队列的最前面的任务给丢弃，然后将重新调用 execute(Runnable) 方法。
	注释说会 which can fail again, causing this to be repeated.
    我的理解是，重新 execute 的时候，有别的线程已经 execute 过了，
    所以仍然无法添加进队列，还需要再次执行拒绝策略，重复次步骤。

# 一些与线程状态和活动线程数相关的变量
```java
   private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));  
   // 将整型的32位分为高3位和低29位，高3位表示线程池的状态,低29位表示活动的线程数  
   private static final int COUNT_BITS = Integer.SIZE - 3;  
   // 29位能表示的最大二进制整数，也就是活动线程数  
   private static final int CAPACITY   = (1 << COUNT_BITS) - 1;
  
   // 高3位数值代表的线程池状态  
   private static final int RUNNING    = -1 << COUNT_BITS;    // running 线程池能接受新任务  
   private static final int SHUTDOWN   =  0 << COUNT_BITS;    // shutdown 线程池不再接受新任务， 但是会处理队列中的任务
   private static final int STOP       =  1 << COUNT_BITS;    // stop 线程池不再接受新任务，不再执行队列中的任务，而且要中断正在处理的任务  
   private static final int TIDYING    =  2 << COUNT_BITS;    // tidying 线程池所有任务均已终止  
   private static final int TERMINATED =  3 << COUNT_BITS;    // terminated terminated()方法执行结束  
```

由如上可知：
ctl是一个AtomicInteger类型的原子对象。ctl记录了"线程池中的任务数量"和"线程池状态"2个信息。ctl共包括32位。其中，高3位表示"线程池状态"，低29位表示"线程池中的任务数量"。

```
RUNNING    -- 对应的高3位值是111
SHUTDOWN   -- 对应的高3位值是000
STOP       -- 对应的高3位值是001
TIDYING    -- 对应的高3位值是010
TERMINATED -- 对应的高3位值是011
```

线程池的各个状态之间的切换如下图所示：
![](http://img.blog.csdn.net/20140216111141953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWF6aGltYXpo/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

一些对常量的操作方法：
```java
private static int runStateOf(int c)     { return c & ~CAPACITY; }  // 得到线程运行状态  
private static int workerCountOf(int c)  { return c & CAPACITY; }   // 得到活动线程数  
private static int ctlOf(int rs, int wc) { return rs | wc; }        // 得到两者表示的值  
```

# 具体的方法
```java
public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
            
        //// 获取线程的数量和状态
        int c = ctl.get();
        // 如果线程的数量 < 核心线程数
        if (workerCountOf(c) < corePoolSize) {
        	// 创建一个线程来执行该任务
            if (addWorker(command, true))
                return;
            // 重新获取线程的数量和状态
            c = ctl.get();
        }
        // 走到这里就说明，线程的数量 >= 核心线程数，或者新建线程的时候失败了
        // 如果线程池正在运行，并且任务能够添加到队列
        if (isRunning(c) && workQueue.offer(command)) {
        	// 需要重新检测线程的状态
            int recheck = ctl.get();
            // 如果线程池停止运行，则将任务从队列中移除，采用拒绝策略来执行该任务
            if (! isRunning(recheck) && remove(command))
                reject(command);
            // 如果线程数量为0,则尝试新建一个线程,新建线程对应的任务为null
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        // 线程池已经关闭，或者无法添加到等待队列（队列已满）
        else if (!addWorker(command, false))
            reject(command);
  }
```

```java
/** 
  * 创建并执行新线程 
  * @param firstTack 用于指定新增的线程执行的第一个任务 
  * 
  * @param core      true表示在新增线程时会判断当前活动线程数是否少于corePoolSize， 
  *                  false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize 
  * 
  * @return 是否成功新增一个线程 
  */  
 private boolean addWorker(Runnable firstTask, boolean core) {  
      retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            // 这个判断条件好蛋疼
            // 转成 rs >= SHUTDOWN && (rs != SHUTDOWN || firstTask != null || workQueue.isEmpty())
            // 即 rs > SHUTDOWN || rs >= SHUTDOWN && firstTask != null || rs >= SHUTDOWN && workQueue.isEmpty()
            // 就是说只要等待队列中还有东西，即使是 SHUTDOWN 状态，也要创建新的线程来处理队列中的任务
            if (rs >= SHUTDOWN &&
                ! (rs == SHUTDOWN &&
                   firstTask == null &&
                   ! workQueue.isEmpty()))
                return false;

            for (;;) {
                int wc = workerCountOf(c);
                // 线程数量已经是最大了，无法创建新的线程了
                if (wc >= CAPACITY ||
                    wc >= (core ? corePoolSize : maximumPoolSize))
                    return false;
                // 如果 c 的值和线程数相等，表示可以创建新的线程，将线程数目加 1，跳出两层 for 循环
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                // 如果值不相等，重新获取状态和数目
                c = ctl.get();  // Re-read ctl
                // 如果状态发生了变化，重新走最外层的 for 循环，没有发生变化，走内层 for 循环
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }

        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int rs = runStateOf(ctl.get());

					// rs < SHUTDOWN，线程池正在运行
                    // rs == SHUTDOWN && firstTask == null 队列中有任务 （需要结合 execute 方法理解）
                    if (rs < SHUTDOWN ||
                        (rs == SHUTDOWN && firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        // 添加任务成功
                        workers.add(w);
                        int s = workers.size();
                        // 更新线程池中线程的最大数
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                // 如果添加成功，运行线程，线程启动成功
                if (workerAdded) {
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
  }
```

addWork 方法中，运行线程是调用了 Thread 的 run 方法。具体过程如下。
```java
		Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }
```

thread 是 Factory 直接 new 出来的，传递的 Runnable 是自己。看看 Worker 的 run() 方法：
```java
		public void run() {
            runWorker(this);
        }
```

```java
	final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        
        try {
            while (task != null || (task = getTask()) != null) {
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &&
                      runStateAtLeast(ctl.get(), STOP))) &&
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }
```