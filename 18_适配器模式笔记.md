# 适配器模式

**适配器模式** 将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。

## 对象和类的适配器

适配器分为两种：“对象”适配器和“类”适配器。

类适配器是什么？
类适配器需要多重继承才能够实现它，这在java中是不可能的。

## 真实世界中的适配器

### 旧世界的枚举器

早期的集合类型都实现了一个名为 elements（） 的方法。该方法会返回一个 Enumeration （枚举）。这个 Enumeration 接口可以逐一走过此集合内的每个元素，而无需知道它们在集合内是如何被管理的。

| <<interface>> Enumeration |
|------------------|
| hasMoreElements() |
| nextElement() |

### 新世界的迭代器

当Sun推出更新后的集合类时，开始使用了 Iterator （迭代器）接口，这个接口和枚举接口很像，都可以让你遍历此集合类型内的每个元素，但不同的是，迭代器还提供了删除元素的能力。

| <<interface>> Iterator |
|------------------|
| hasNext() |
| next() |
| remove() |

而今天......

面对遗留代码，这个代码暴露出枚举器接口，但我们又希望在新的代码中只使用迭代器。想解决这个问题，看来我们需要构造一个适配器。

## 外观模式

**外观模式** 提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

适配器模式将一个或者多个类接口变成客户所期望的一个接口。虽然大多数教科书所采用的例子中适配器只适配一个类，但是你可以适配许多类来提供一个接口让客户编码。类似的，一个外观也可以只针对一个拥有复杂接口的类提供简化的接口。两种模式的差异，不在于它们“包装”了几个类，而是在于它们的意图。适配器模式的意图是，“改变”接口符合客户的期望；而外观模式的意图是，提供子系统的一个简化接口。