# 补码

## 原码

原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

```java
[+1]原 = 0000 0001

[-1]原 = 1000 0001
```

第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:

```java
[1111 1111 , 0111 1111]

```
即

```java
[-127 , 127]
```

原码是人脑最容易理解和计算的表示方式。

## 反码


反码的表示方法是:

正数的反码是其本身

负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.
```java
[+1] = [00000001]原 = [00000001]反

[-1] = [10000001]原 = [11111110]反
```
## 补码

补码的表示方法是:

正数的补码就是其本身

负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

```java
[+1] = [00000001]原 = [00000001]反 = [00000001]补

[-1] = [10000001]原 = [11111110]反 = [11111111]补
```

## 为什么要用补码？
首先， 因为人脑可以知道第一位是符号位。在计算的时候我们会根据符号位, 选择对真值区域的加减。
但是对于计算机，加减乘数已经是最基础的运算，要设计的尽量简单。
计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法。
我们知道， 根据运算法则减去一个正数等于加上一个负数， 即：1-1 = 1 + (-1) = 0 ，所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。于是人们将符号位参与运算，并且只保留加法。

### 补码的原理

#### 模与互补、同余


我们将一个时钟的分针往前拨20分钟，和往后拨40分钟，得到的结果是一样的。
把你的属年(属猴)往后退5年，和往前进7年，一样都是属兔。
把数字 87，减去 25，和加上 75，在不考虑百位数的条件下，得到的结果都是62。
```java
  上述几组数字，有这样的关系： 
　　  20 + 40 = 60 
　　  5 + 7 = 12 
　　  25 + 75 = 100 
  式中的 60、12 和 100，就是“模”。 
  式中的 20和40、5和7，以及25和75，就是一对对“互补”的数字。 
  而且20，80，140在模是60的情况下就是互为“同余”的数字。 
  ```
  通俗解释下模、补数、同余的概念：

**模**：就是一个轮回，比如分针转一圈，十二生肖一轮等等。
**互补** ：一个数值针对某个模的互补值就是这个数值加上或者减去多少能够等于模，或者等于模的同余值。
**同余** ：一个数值加上或者减去模的整数倍得到的所有数值即为该数值的同余值(也就是除上模，余数是一样，所以叫同余)，0是模的同余，-模也是模的同余。

#### 互补的值有什么作用呢？

如果我们在进行减法运算时，用与减数互补的值代替减数与被减数进行加法运算会发生什么呢？废话不多说，看示例。 
  ```java
示例1：在分钟刻度下，计算55分钟往后拨动34分钟，转化成数学计算就是：55-34

被减数		55
减数 		 34
减数补数	60-34==26
最终结果	55+26==81
```
用减数补数代替减数得到结果为81,81在分钟刻度盘上正好是21，也就是81是21的同余值，和55-34是一样的。
注意：这里忽略了进位。

**可以看出我们在进行减法运算的时候，可以讲负数转换为其互补数。因为在计算机中 int 类型的数有固定的字节大小，即表示的范围是有限的，所以计算负数使用的摸就是除去符号位能表示的最大值了。**

看下面一个公式：
X-Y ==== X+(M-Y) ==== X+((M-1)-Y+1)

M-1-Y 就是 Y 的反码。
M-1-Y+1 就是 Y 的反码 + 1 就是 Y 的补码。