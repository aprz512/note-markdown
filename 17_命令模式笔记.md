# 命令模式

## 定义

命令模式讲“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。

一个命令对象通过在特定接受者上绑定一组动作来封装一个请求。要达到这一点，命令对象将动作和接受者包进对象中。这个对象只暴露出一个 execute() 方法，当此方法被调用的时候，接受者就会进行这些动作。从外面来看，其他对象不知道究竟哪个接收者进行了哪些动作，只知道如果调用 execute() 方法，请求的目的就能达到。

## 用途

**命令模式可以用作：队列请求。**

命令可以讲运算块打包（一个接受者和一组动作），然后将它传来传去，就像是一般的对象一样。现在，即使在命令对象被创建许久之后，运算依然可以被调用。事实上，它甚至可以在不同的线程中被调用。我们可以利用这样的特性衍生一些应用，例如：日程安排（Scheduler），线程池，工作队列等。

想象有一个工作队列：你在某一端添加命令，然后另一端则是线程。线程进行下面的动作：从队列中取出一个命令，调用它的 execute() 方法，等待这个调用完成，然后将此命令对象丢弃，再取出下一个命令......

**命令模式可以用作：日志请求。**

某些应用需要我们讲所有的动作都记录在日志中，并能在系统死机之后，重新调用这些动作恢复到之前的状态。通过新增两个方法（store(), load()），命令模式就能够支持这一点。在java中，我们可以利用对象的序列化（Serialization）实现这些方法，但是一般认为序列化最好还是只用在对象的持久化上（presistence）。

要怎么做呢？当我们执行命令的时候，将历史记录储存在磁盘中。一旦系统死机，我们就可以讲命令对象重新加载，并成批地依次调用这些对象的 execute() 方法。

有许多调用大型数据结构的动作的应用无法在每次改变发生时被快速地储存。通过使用记录日志，我们可以将上次检查点（checkpoint）之后的所有操作记录下来，如果系统出状况，从检查点开始应用这些操作。比方说，对于电子表格应用，我们可能想要实现的错误恢复方式是将电子表格的操作记录在日志中，而不是每次电子表格一有变化就记录整个电子表格。对更高级的应用而言，这些技巧可以被扩展应用到事务（transaction）处理中，也就是说，一整群操作必须全部进行完成，或者没有进行任何的操作。