#### 使用JIT编译器时，App性能状况

![](jit.png)

优点：

- 安装迅速
- 安装时所需容量小

缺点：

- 使用了JIT，在运行时编译，导致电量消耗快
- JIT本身也有开销

#### 使用AOT编译器的时候，App性能状况

![](aot.png)

优点：

- 启动快
- 运行快（不卡顿），因为直接执行的机器码
- 电量消耗少，没有了JIT

缺点：

- 安装慢，因为安装的时候需要将 .dex 编译成本地机器码。
- 需要更大的安装空间，因为将 .dex 编译成机器码之后，需要储存起来。

#### AOT编译方案面临的挑战

![](aot_challenges.png)

- 由于系统更新时，所有的应用都需要重新安装，这会导致所有的应用都需要在重新编译一遍，如果你的应用贼多的话......。
- 编译之后的native code会比较大，消耗了储存空间，如果你的应用非常大的话，一些小容量的手机可能无法安装。
- 这中编译行为对动态apk的支持不是很好。

可以看到，JIT与AOT的优缺点完全是反过来的，Google大佬就将这两个方案结合起来，整出了混合编译。

#### Google大佬的解决方案，混合编译

![](android_n.png)

发现JIT又回来了。

当用户安装App的时候，不再进行预编译了，这个和KitKat的时候一样。当用户安装之后立即使用该App，仍然使用JIT编译模式来执行App，但是同时会生成一个离线的 profile 文件，这个 profile 文件会记录JIT运行时的所有 hot code（热点代码）信息。然后在未来的某个时间点，Android Framework 会基于这个 profile 文件来启动一个预编译行为，它只便于记录的热点代码。

在 JIT 阶段，它带来的好处：

- 快速安装
- 系统快速更新

在 AOT 阶段，它带来的好处：

- 快速启动，更好的运行性能
- 低消耗：CPU，储存空间，电量...

#### ART混合编译模式

- 一些用户只使用App中的一部分功能，只有这些被频繁使用的部分（这个功能涉及到的代码）才值得被编译成 native code。
- 在 JIT 阶段，我们可以很容易的找到经常被使用的代码。
- 使用 AOT 来加快这些经常使用的用例。
- 避免在一些基本不适用的代码上花费开销。

### 混合编译与AOT的性能比较

![](performance1.png)

![](performance2.png)

![1540221641850](performance3.PNG)

有意思的是，AOT与JIT在Micro Benchmark测试中各有优劣。



参考文档：

https://www.youtube.com/watch?v=TCJLFqhC1VE